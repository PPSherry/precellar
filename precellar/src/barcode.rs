use anyhow::{bail, Result};
use itertools::Itertools;
use log::info;
use noodles::sam::alignment::{
    record::data::field::{Tag, Value},
    Record,
};
use rand::distr::{slice::Choose, Distribution};
use std::{
    collections::HashMap,
    ops::{Deref, DerefMut},
};

const BC_MAX_QV: u8 = 66; // This is the illumina quality value
pub(crate) const BASE_OPTS: [u8; 4] = [b'A', b'C', b'G', b'T'];

/// A map of oligo species to their frequency in a given library.
#[derive(Debug, Clone)]
pub struct OligoFrequncy(HashMap<Vec<u8>, usize>);

impl Deref for OligoFrequncy {
    type Target = HashMap<Vec<u8>, usize>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for OligoFrequncy {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl FromIterator<(Vec<u8>, usize)> for OligoFrequncy {
    fn from_iter<I: IntoIterator<Item = (Vec<u8>, usize)>>(iter: I) -> Self {
        Self(iter.into_iter().collect())
    }
}

// Implement default for OligoFrequncy
impl Default for OligoFrequncy {
    fn default() -> Self {
        Self::new()
    }
}

impl OligoFrequncy {
    pub fn new() -> Self {
        Self(HashMap::new())
    }

    /// The likelihood of a query oligo being generated by the library.
    /// If the query is present in the library, the likelihood is 1.0.
    /// Otherwise, the likelihood is calculated as
    pub fn likelihood<'a>(
        &'a self,
        query: &'a [u8],
        qual: &[u8],
        n_mismatch: usize,
    ) -> (&'a [u8], f64) {
        if n_mismatch == 0 {
            if self.0.contains_key(query) {
                (query, 1.0)
            } else {
                (query, 0.0)
            }
        } else if n_mismatch == 1 {
            self.likelihood1(query, qual)
        } else if n_mismatch == 2 {
            self.likelihood2(query, qual)
        } else {
            todo!()
        }
    }

    /// The likelihood up to 2 mismatches.
    fn likelihood2<'a>(&'a self, query: &'a [u8], qual: &[u8]) -> (&'a [u8], f64) {
        if self.0.contains_key(query) {
            return (query, 1.0);
        }

        let mut best_option = None;
        let mut total_likelihood = 0.0;
        let mut query_bytes = query.to_vec();

        // Single mismatch loop
        for (pos1, &qv1) in qual.iter().enumerate() {
            let qv1 = qv1.min(BC_MAX_QV);
            let original1 = query_bytes[pos1];

            for base1 in BASE_OPTS {
                if base1 != original1 {
                    query_bytes[pos1] = base1;

                    // Check for 1-mismatch barcode match
                    if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                        let bc_count = 1 + raw_count;
                        let likelihood = bc_count as f64 * error_probability(qv1);
                        update_best_option(&mut best_option, likelihood, key);
                        total_likelihood += likelihood;
                    }

                    // Loop for the second mismatch
                    for (pos2, &qv2) in qual.iter().enumerate().skip(pos1 + 1) {
                        let qv2 = qv2.min(BC_MAX_QV);
                        let original2 = query_bytes[pos2];

                        for val2 in BASE_OPTS {
                            if val2 != original2 {
                                query_bytes[pos2] = val2;

                                // Check for 2-mismatch barcode match
                                if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                                    let bc_count = 1 + raw_count;
                                    let likelihood = bc_count as f64
                                        * error_probability(qv1)
                                        * error_probability(qv2);
                                    update_best_option(&mut best_option, likelihood, key);
                                    total_likelihood += likelihood;
                                }
                            }
                        }
                        // Restore original value for second position
                        query_bytes[pos2] = original2;
                    }
                }
            }
            // Restore original value for first position
            query_bytes[pos1] = original1;
        }

        if let Some((best_like, best_bc)) = best_option {
            (best_bc, best_like / total_likelihood)
        } else {
            (query, 0.0)
        }
    }

    /// The likehood up to 1 mismatch.
    fn likelihood1<'a>(&'a self, query: &'a [u8], qual: &[u8]) -> (&'a [u8], f64) {
        if self.0.contains_key(query) {
            return (query, 1.0);
        }

        let mut best_option = None;
        let mut total_likelihood = 0.0;
        let mut query_bytes = query.to_vec();
        for (pos, &qv) in qual.iter().enumerate() {
            let qv = qv.min(BC_MAX_QV);
            let existing = query_bytes[pos];
            for val in BASE_OPTS {
                if val != existing {
                    query_bytes[pos] = val;
                    if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                        let bc_count = 1 + raw_count;
                        let likelihood = bc_count as f64 * error_probability(qv);
                        update_best_option(&mut best_option, likelihood, key);
                        total_likelihood += likelihood;
                    }
                }
            }
            query_bytes[pos] = existing;
        }

        if let Some((best_like, best_bc)) = best_option {
            (best_bc, best_like / total_likelihood)
        } else {
            (query, 0.0)
        }
    }
}

// Helper function to update the best option
fn update_best_option<'a>(
    best_option: &mut Option<(f64, &'a [u8])>,
    likelihood: f64,
    key: &'a [u8],
) {
    match best_option {
        None => *best_option = Some((likelihood, key)),
        Some(ref old_best) => {
            if old_best.0 < likelihood {
                *best_option = Some((likelihood, key));
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct Whitelist {
    whitelist_exists: bool,
    barcode_counts: OligoFrequncy,
    mismatch_count: usize,
    pub(crate) total_count: usize,
    pub(crate) total_base_count: u64,
    q30_base_count: u64,
    base_qual_sum: i64,
}

impl Whitelist {
    /// Return the number of barcodes in the whitelist. If the whitelist does not exist, return 0.
    pub fn len(&self) -> usize {
        if self.whitelist_exists {
            self.barcode_counts.len()
        } else {
            0
        }
    }

    pub fn empty() -> Self {
        Self {
            whitelist_exists: false,
            barcode_counts: OligoFrequncy::new(),
            mismatch_count: 0,
            total_count: 0,
            total_base_count: 0,
            q30_base_count: 0,
            base_qual_sum: 0,
        }
    }

    /// Create a new whitelist from an iterator of strings.
    pub fn new<I: IntoIterator<Item = S>, S: Into<Vec<u8>>>(iter: I) -> Self {
        let mut whitelist = Self::empty();
        whitelist.whitelist_exists = true;
        whitelist.barcode_counts = iter.into_iter().map(|x| (x.into(), 0)).collect();
        whitelist
    }

    /// Update the barcode counter with a barcode and its quality scores.
    pub fn count_barcode(&mut self, barcode: &[u8], barcode_qual: &[u8]) {
        if self.whitelist_exists {
            if let Some(count) = self.barcode_counts.get_mut(barcode) {
                *count += 1;
            } else {
                self.mismatch_count += 1;
            }
        } else if barcode.len() > 1 && barcode.iter().all(|x| BASE_OPTS.contains(x)) {
            *self.barcode_counts.entry(barcode.to_vec()).or_insert(0) += 1;
        } else {
            self.mismatch_count += 1;
        }

        self.total_count += 1;

        for &qual in barcode_qual {
            let qual_int = (qual as u32) - 33;
            self.base_qual_sum += qual_int as i64;
            if qual_int >= 30 {
                self.q30_base_count += 1;
            }
            self.total_base_count += 1;
        }
    }

    pub fn predict_whitelist(&mut self) {
        if !self.whitelist_exists && !self.barcode_counts.is_empty() {
            info!("Predicting whitelist from {} barcode ...", self.barcode_counts.len());
            let counts = self
                .barcode_counts
                .iter()
                .map(|x| x.1)
                .copied()
                .collect::<Vec<_>>();
            let threshold = compute_cell_filter_threshold(&counts);
            self.barcode_counts = self
                .barcode_counts
                .0
                .clone()
                .into_iter()
                .filter(|x| x.1 >= threshold)
                .collect();
            self.whitelist_exists = true;
            info!(
                "Predicted whitelist contains {} barcodes",
                self.barcode_counts.len()
            );
        }
    }

    pub fn num_seen_barcodes(&self) -> usize {
        self.barcode_counts.values().filter(|&&x| x > 0).count()
    }

    pub fn get_barcode_counts(&self) -> &OligoFrequncy {
        &self.barcode_counts
    }

    pub fn mean_base_quality_score(&self) -> f64 {
        if self.total_base_count == 0 {
            // u64 never < 0
            0.0
        } else {
            self.base_qual_sum as f64 / self.total_base_count as f64
        }
    }

    pub fn frac_q30_bases(&self) -> f64 {
        if self.total_base_count == 0 {
            0.0
        } else {
            self.q30_base_count as f64 / self.total_base_count as f64
        }
    }

    pub fn frac_exact_match(&self) -> f64 {
        if self.total_count == 0 {
            0.0
        } else {
            1.0 - (self.mismatch_count as f64 / self.total_count as f64)
        }
    }
}

/// A barcode validator that uses a barcode counter to validate barcodes.
#[derive(Debug, Clone)]
pub struct BarcodeCorrector {
    /// threshold for sum of probability of error on barcode QVs. Barcodes exceeding
    /// this threshold will be marked as not valid.
    max_expected_errors: f64,
    /// if the posterior probability of a correction
    /// exceeds this threshold, the barcode will be corrected.
    bc_confidence_threshold: f64,
    /// The number of mismatches allowed in barcode
    max_mismatch: usize,
}

impl Default for BarcodeCorrector {
    fn default() -> Self {
        Self {
            max_expected_errors: f64::MAX,
            bc_confidence_threshold: 0.975,
            max_mismatch: 1,
        }
    }
}

impl BarcodeCorrector {
    pub fn with_bc_confidence_threshold(mut self, threshold: f64) -> Self {
        self.bc_confidence_threshold = threshold;
        self
    }

    pub fn with_max_missmatch(mut self, max_mismatch: usize) -> Self {
        self.max_mismatch = max_mismatch;
        self
    }
}

#[derive(Copy, Clone, Debug)]
pub enum BarcodeError {
    ExceedExpectedError(f64),
    LowConfidence(f64),
    NoMatch,
}

impl BarcodeCorrector {
    /// Determine if a barcode is valid. A barcode is valid if any of the following conditions are met:
    /// 1) It is in the whitelist and the number of expected errors is less than the max_expected_errors.
    /// 2) It is not in the whitelist, but the number of expected errors is less than the max_expected_errors and the corrected barcode is in the whitelist.
    /// 3) If the whitelist does not exist, the barcode is always valid.
    ///
    /// Return the corrected barcode
    pub fn correct<'a>(
        &'a self,
        barcode_counts: &'a OligoFrequncy,
        barcode: &'a [u8],
        qual: &[u8],
    ) -> Result<&'a [u8], BarcodeError> {
        let expected_errors: f64 = qual.iter().map(|&q| error_probability(q)).sum();
        if expected_errors >= self.max_expected_errors {
            return Err(BarcodeError::ExceedExpectedError(expected_errors));
        }

        let (bc, prob) = barcode_counts.likelihood(barcode, qual, self.max_mismatch);
        if prob <= 0.0 {
            Err(BarcodeError::NoMatch)
        } else if prob >= self.bc_confidence_threshold {
            Ok(bc)
        } else {
            Err(BarcodeError::LowConfidence(prob))
        }
    }
}

/// Convert Illumina quality scores to base-calling error probabilities, i.e.,
/// the probability of an incorrect base call.
#[inline(always)]
fn error_probability(qual: u8) -> f64 {
    let offset = 33.0; // Illumina quality score offset
    10f64.powf(-((qual as f64 - offset) / 10.0))
}

/// Gets the cell barcode from a BAM record.
pub fn get_barcode<R: Record>(record: &R) -> Result<Option<String>> {
    if let Some(data_result) = record.data().get(&Tag::CELL_BARCODE_ID) {
        if let Ok(Value::String(bc)) = data_result {
            match std::str::from_utf8(bc) {
                Ok(s) => {
                    return Ok(Some(s.to_string()));
                }
                Err(e) => {
                    bail!("Failed to parse cell barcode as UTF-8: {}", e)
                }
            }
        }
    }
    Ok(None)
}

pub(crate) fn get_umi<R: Record>(rec: &R) -> Result<Option<String>> {
    Ok(rec
        .data()
        .get(&Tag::UMI_SEQUENCE)
        .transpose()?
        .and_then(|x| match x {
            Value::String(umi) => Some(umi.to_string()),
            _ => None,
        }))
}

/// Compute the knee point from a descending sorted list of counts.
/// The order of the counts is assumed to be descending and is not checked.
/// The knee point is the point on the curve where the second derivative is maximized.
fn get_knee_point(sorted_counts: &[usize]) -> usize {
    // Find the point of maximum curvature on log-log scale
    let mut max_curvature = 0.0;
    let mut knee_idx = 0;

    for i in 1..(sorted_counts.len().min(10000) - 1) {
        if sorted_counts[i] == 0 {
            break;
        }

        let prev = ((i - 1) as f64 + 1.0).ln();
        let curr = ((i) as f64 + 1.0).ln();
        let next = ((i + 1) as f64 + 1.0).ln();

        let prev_val = (sorted_counts[i - 1] as f64).ln();
        let curr_val = (sorted_counts[i] as f64).ln();
        let next_val = (sorted_counts[i + 1] as f64).ln();

        // Approximate second derivative at point i
        let curvature =
            ((next_val - curr_val) / (next - curr)) - ((curr_val - prev_val) / (curr - prev));

        if curvature.abs() > max_curvature {
            max_curvature = curvature.abs();
            knee_idx = i;
        }
    }

    knee_idx
}

/// Get the range of values to use for empty drops background by chemistry type
fn get_empty_drops_range(
    chemistry_description: Option<&str>,
    num_probe_bcs: Option<usize>,
) -> (usize, usize) {
    let n_partitions = match chemistry_description {
        Some("v3LT") => 9000,
        Some("v4") => {
            if let Some(probe_bcs) = num_probe_bcs {
                if probe_bcs > 1 {
                    80000 * probe_bcs
                } else {
                    160000
                }
            } else {
                160000
            }
        }
        _ => {
            if let Some(probe_bcs) = num_probe_bcs {
                if probe_bcs > 1 {
                    45000 * probe_bcs
                } else {
                    90000
                }
            } else {
                90000
            }
        }
    };

    (n_partitions / 2, n_partitions)
}

fn compute_cell_filter_threshold(counts: &[usize]) -> usize {
    let nonzero_counts: Vec<_> = counts
        .iter()
        .filter(|&&x| x > 0)
        .copied()
        .sorted()
        .collect();
    let n = nonzero_counts.len();
    let quantile = 0.99;
    let num_bootstrap_samples = 1000;
    let distr = Choose::new(&nonzero_counts).unwrap();

    let num_recovered = (0..num_bootstrap_samples)
        .map(|_| {
            let sample: Vec<_> = distr
                .sample_iter(&mut rand::rng())
                .take(n)
                .copied()
                .sorted()
                .collect();
            estimate_recovered_cells_ordmag(&sample)
        })
        .sum::<usize>() as f64
        / num_bootstrap_samples as f64;

    let baseline_idx = (num_recovered * (1.0 - quantile)).round() as usize;
    let baseline_idx = baseline_idx.min(n.saturating_sub(1));

    let top_n = (0..num_bootstrap_samples)
        .map(|_| {
            let sample: Vec<_> = distr
                .sample_iter(&mut rand::rng())
                .take(n)
                .copied()
                .sorted()
                .collect();
            find_within_ordmag(&sample, baseline_idx)
        })
        .sum::<usize>() as f64
        / num_bootstrap_samples as f64;
    let top_n = top_n.round() as usize;

    nonzero_counts[n - top_n - 1]
}

/// Estimate the number of recovered cells using order-of-magnitude approach.
// The OrdMag algorithm estimates the initial number of recovered cells by calling
// barcodes as cells if their total UMI counts exceed m/10, where m is the 99th
// percentile of the top N barcodes based on total UMI counts. The estimation
// process involves finding a value x that approximates OrdMag(x) by minimizing a
// loss function: (OrgMag(x) - x)^2 / x.
fn estimate_recovered_cells_ordmag(sorted_counts: &[usize]) -> usize {
    let quantile = 0.99;
    let n = sorted_counts.len();

    let mut max = 18;
    let mut num_recoverd = 1;
    std::iter::from_fn(|| {
        max -= 1;
        if max >= 0 {
            let baseline_idx = (num_recoverd as f64 * (1.0 - quantile)).round() as usize;
            let baseline_idx = baseline_idx.min(n.saturating_sub(1));
            let num_obs = find_within_ordmag(sorted_counts, baseline_idx);
            let loss = compute_loss(num_obs, num_recoverd);
            let result = (num_recoverd, loss);
            num_recoverd <<= 1;
            Some(result)
        } else {
            None
        }
    })
    .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
    .unwrap()
    .0
}

fn find_within_ordmag(sorted_counts: &[usize], baseline_idx: usize) -> usize {
    let n = sorted_counts.len();
    let baseline = sorted_counts[n - baseline_idx - 1];
    let cutoff = ((0.1 * baseline as f64).round() as usize).max(1);
    n - sorted_counts.binary_search(&cutoff).unwrap_or_else(|x| x)
}

fn compute_loss(num_obs: usize, num_exp: usize) -> f64 {
    (num_obs - num_exp).pow(2) as f64 / num_exp as f64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_whitelist() {
        let whitelist = Whitelist::empty();
        assert_eq!(whitelist.num_seen_barcodes(), 0);
        assert_eq!(whitelist.total_count, 0);
        assert_eq!(whitelist.total_base_count, 0);
        assert_eq!(whitelist.mean_base_quality_score(), 0.0);
        assert_eq!(whitelist.frac_q30_bases(), 0.0);
        assert_eq!(whitelist.frac_exact_match(), 0.0);
    }

    #[test]
    fn test_new_whitelist() {
        let barcodes = ["ACGTACGT", "TGCATGCA", "GATCGATC"];
        let whitelist = Whitelist::new(barcodes);

        assert!(whitelist.whitelist_exists);
        assert_eq!(whitelist.num_seen_barcodes(), 0); // No barcodes counted yet
        assert_eq!(whitelist.total_count, 0);

        // Check that the whitelist contains the correct barcodes
        let barcode_counts = whitelist.get_barcode_counts();
        for barcode in barcodes {
            assert!(barcode_counts.contains_key(&barcode.as_bytes().to_vec()));
            assert_eq!(barcode_counts[&barcode.as_bytes().to_vec()], 0);
        }
    }

    #[test]
    fn test_count_barcode_with_whitelist() {
        let barcodes = ["ACGTACGT", "TGCATGCA", "GATCGATC"];
        let mut whitelist = Whitelist::new(barcodes);

        // Count an exact match
        let barcode = b"ACGTACGT";
        let quality = b"FFFFFFFI"; // Quality scores (~37, above Q30)
        whitelist.count_barcode(barcode, quality);

        assert_eq!(whitelist.total_count, 1);
        assert_eq!(whitelist.total_base_count, 8);
        assert_eq!(whitelist.get_barcode_counts()[&barcode.to_vec()], 1);
        assert_eq!(whitelist.num_seen_barcodes(), 1);
        assert_eq!(whitelist.frac_exact_match(), 1.0);

        // Count a barcode not in whitelist
        let barcode_not_in_list = b"GGGGGGGG";
        let quality2 = b"IIIIIFFF"; // Mix of quality scores
        whitelist.count_barcode(barcode_not_in_list, quality2);

        assert_eq!(whitelist.total_count, 2);
        assert_eq!(whitelist.total_base_count, 16);
        assert_eq!(whitelist.mismatch_count, 1);
        assert_eq!(whitelist.frac_exact_match(), 0.5); // 1 out of 2 matched exactly
    }

    #[test]
    fn test_count_barcode_without_whitelist() {
        let mut whitelist = Whitelist::empty();

        // Add several barcodes with varying quality scores
        whitelist.count_barcode(b"ACGTACGT", b"FFFFFFFF");
        whitelist.count_barcode(b"ACGTACGT", b"FFFFFFFF");
        whitelist.count_barcode(b"TGCATGCA", b"BBBBBBBB");

        assert_eq!(whitelist.total_count, 3);
        assert_eq!(whitelist.total_base_count, 24);
        assert_eq!(whitelist.num_seen_barcodes(), 2);

        let barcode_counts = whitelist.get_barcode_counts();
        assert_eq!(barcode_counts[&b"ACGTACGT".to_vec()], 2);
        assert_eq!(barcode_counts[&b"TGCATGCA".to_vec()], 1);
    }

    #[test]
    fn test_quality_statistics() {
        let mut whitelist = Whitelist::empty();

        // Add barcodes with different quality scores
        // ASCII 70 ('F') = Q37, ASCII 66 ('B') = Q33, ASCII 63 ('?') = Q30, ASCII 62 ('>') = Q29
        whitelist.count_barcode(b"ACGTACGT", b"FFFFFFFF"); // All Q37
        whitelist.count_barcode(b"TGCATGCA", b"????BBBB"); // Mixed Q30 and Q33
        whitelist.count_barcode(b"GATCGATC", b">>>>>>>>"); // All Q29 (below Q30)

        // Calculate expected values
        let total_bases = 24.0;
        let q30_bases = 8.0 + 8.0; // First two barcodes have Q30+ bases
        let expected_q30_fraction = q30_bases / total_bases;

        let sum_qual = (8 * (70 - 33)) + (4 * (63 - 33)) + (4 * (66 - 33)) + (8 * (62 - 33));
        let expected_mean_quality = sum_qual as f64 / total_bases;

        assert_eq!(whitelist.total_base_count, 24);
        assert_eq!(whitelist.frac_q30_bases(), expected_q30_fraction);
        assert!((whitelist.mean_base_quality_score() - expected_mean_quality).abs() < 0.001);
    }

    #[test]
    fn test_with_sample_barcode_distribution() {
        let mut whitelist = Whitelist::empty();

        // Add barcodes with different counts
        let barcodes = [
            (b"ACGTACGT".to_vec(), 1000), // Max count
            (b"TGCATGCA".to_vec(), 900),
            (b"GATCGATC".to_vec(), 800),
            (b"CTACGTAC".to_vec(), 500),
            (b"ACACGTGT".to_vec(), 100),
            (b"GTGTCACA".to_vec(), 80),
            (b"TCAGTCAG".to_vec(), 50),
            (b"CAGTTCAG".to_vec(), 30),
            (b"AGTCAGTC".to_vec(), 10),
            (b"TCAGTCAG".to_vec(), 5),
        ];

        // Simulate counting by adding each barcode the specified number of times
        for (barcode, count) in barcodes.iter() {
            // Create a quality string of the same length as the barcode
            let quality = vec![b'F'; barcode.len()];

            for _ in 0..*count {
                whitelist.count_barcode(barcode, &quality);
            }
        }

        // Check the total count matches what we expect
        let expected_total = barcodes.iter().map(|(_, count)| count).sum::<usize>();
        assert_eq!(whitelist.total_count, expected_total);

        // Check that we have the right number of unique barcodes
        // Note: one barcode appears twice in the list (TCAGTCAG)
        assert_eq!(whitelist.num_seen_barcodes(), 9);

        // Check specific barcode counts
        let counts = whitelist.get_barcode_counts();
        assert_eq!(counts[&b"ACGTACGT".to_vec()], 1000);
        assert_eq!(counts[&b"AGTCAGTC".to_vec()], 10);
        assert_eq!(counts[&b"TCAGTCAG".to_vec()], 55); // 50 + 5
    }

    #[test]
    fn test_find_within_ordmag() {
        let counts = &[50, 60, 70, 80, 90, 100, 700, 800, 900, 1000];

        // With baseline_idx 0 (using max value as baseline)
        // baseline = 1000, cutoff = 100
        assert_eq!(find_within_ordmag(counts, 0), 5);

        // With baseline_idx 1 (using second highest value as baseline)
        // baseline = 900, cutoff = 90
        assert_eq!(find_within_ordmag(counts, 1), 6);
    }
}
